#!/usr/bin/env bash

: <<'END'
dhedit
DigiHub User Configuration Editor

Version 1.0a

Steve de Bode - KQ4ZCI - December 2025

Input:	callsign
Output: none - interactive
END

set -euo pipefail

colr='\e[31m'; colb='\033[34m'; ncol='\e[0m'

HomePath="${HOME}"
PROFILE_FILE="${HomePath}/.profile"
DHINFO_FILE="${HomePath}/.dhinfo"

# --------------- Helpers ---------------

trim() {
  printf '%s' "$1" | sed -e 's/^[[:space:]]\+//' -e 's/[[:space:]]\+$//'
}

backup_file() {
  local f="$1"
  [[ -f "$f" ]] || return 0
  local ts
  ts="$(date +%Y%m%d-%H%M%S)"
  cp -a -- "$f" "${f}.bak.${ts}"
}

YnCont() {
  while true; do
    local response
    read -r -n1 -p 'Continue (Y/n)? ' response
    printf '\n'
    case "$response" in
      ''|Y|y) return 0 ;;
      N|n)    return 1 ;;
      *) printf '%s\n' 'Invalid response, please select Y/n' >&2 ;;
    esac
  done
}

PromptEdit() {
  local __var="$1"
  local label="$2"
  local required="${3:-0}"

  while true; do
    local cur="${!__var-}"
    local reply
    if [[ -n "$(trim "${cur}")" ]]; then
      read -r -p "${label} [${cur}]: " reply
    else
      read -r -p "${label}: " reply
    fi

    if [[ -n "$reply" ]]; then
      printf -v "$__var" '%s' "$reply"
      return 0
    fi

    if [[ -n "$(trim "${cur}")" ]]; then
      return 0
    fi

    if (( required == 0 )); then
      printf -v "$__var" '%s' ''
      return 0
    fi

    printf '%s\n' 'This field is required.' >&2
  done
}

SetUnknownIfEmpty() {
  for var in "$@"; do
    local v="${!var-}"
    v="$(trim "${v}")"
    if [[ -z "$v" ]]; then
      printf -v "$var" '%s' 'Unknown'
    else
      printf -v "$var" '%s' "$v"
    fi
  done
}

BuildFullName() {
  local parts=()
  [[ -n "${forename-}" && "${forename}" != 'Unknown' ]] && parts+=("$forename")
  [[ -n "${initial-}"  && "${initial}"  != 'Unknown' ]] && parts+=("$initial")
  [[ -n "${surname-}"  && "${surname}"  != 'Unknown' ]] && parts+=("$surname")
  [[ -n "${suffix-}"   && "${suffix}"   != 'Unknown' ]] && parts+=("$suffix")

  if ((${#parts[@]} == 0)); then
    fullname='Unknown'
  else
    fullname="${parts[*]}"
  fi
}

BuildAddress() {
  local parts=()

  [[ -n "${street-}" && "${street}" != 'Unknown' ]] && parts+=("$street")
  [[ -n "${town-}"   && "${town}"   != 'Unknown' ]] && parts+=("$town")

  local statezip=''
  [[ -n "${state-}" && "${state}" != 'Unknown' ]] && statezip="$state"
  [[ -n "${zip-}"   && "${zip}"   != 'Unknown' ]] && statezip="${statezip:+$statezip }$zip"
  [[ -n "$statezip" ]] && parts+=("$statezip")

  [[ -n "${country-}" && "${country}" != 'Unknown' ]] && parts+=("$country")

  if ((${#parts[@]} == 0)); then
    address='Unknown'
  else
    address="$(printf '%s' "${parts[0]}")"
    local i
    for ((i=1; i<${#parts[@]}; i++)); do
      address="${address}, ${parts[i]}"
    done
  fi
}

require_profile() {
  if [[ ! -f "$PROFILE_FILE" ]]; then
    printf '%s\n' 'ERROR: ~/.profile not found. Run the installer first.' >&2
    exit 1
  fi
}

profile_get_export() {
  local name="$1"
  local line
  line="$(grep -E "^[[:space:]]*export[[:space:]]+${name}=" "$PROFILE_FILE" 2>/dev/null | tail -n1 || true)"
  if [[ -n "$line" ]]; then
    printf '%s' "${line#*=}" | sed -e 's/^"//' -e 's/"$//'
  else
    printf '%s' ''
  fi
}

profile_set_export() {
  local name="$1"
  local value="$2"
  local tmp
  tmp="$(mktemp)"

  if grep -qE "^[[:space:]]*export[[:space:]]+${name}=" "$PROFILE_FILE" 2>/dev/null; then
    perl -pe "s/^[[:space:]]*export[[:space:]]+${name}=.*$/export ${name}=${value}/m" "$PROFILE_FILE" > "$tmp"
  else
    if grep -qF '# DigiHub Installation' "$PROFILE_FILE" 2>/dev/null; then
      awk -v ins="export ${name}=${value}" '
        { print }
        $0 ~ /^# DigiHub Installation$/ { print ins }
      ' "$PROFILE_FILE" > "$tmp"
    else
      cat "$PROFILE_FILE" > "$tmp"
      printf '\n%s\n' "export ${name}=${value}" >> "$tmp"
    fi
  fi

  mv -- "$tmp" "$PROFILE_FILE"
}

profile_set_path_line() {
  local desired="$1"
  if ! grep -qF "$desired" "$PROFILE_FILE" 2>/dev/null; then
    if grep -qF '# DigiHub Installation' "$PROFILE_FILE" 2>/dev/null; then
      awk -v ins="$desired" '
        { print }
        $0 ~ /^# DigiHub Installation$/ { print ins }
      ' "$PROFILE_FILE" > "${PROFILE_FILE}.tmp.$$"
      mv -- "${PROFILE_FILE}.tmp.$$" "$PROFILE_FILE"
    else
      printf '\n%s\n' "$desired" >> "$PROFILE_FILE"
    fi
  fi
}

load_from_dhinfo() {
  [[ -f "$DHINFO_FILE" ]] || return 0
  IFS=',' read -r \
    callsign class expiry grid lat lon licstat \
    forename initial surname suffix \
    street town state zip country < "$DHINFO_FILE" || true

  for v in callsign class expiry grid lat lon licstat forename initial surname suffix street town state zip country; do
    printf -v "$v" '%s' "$(trim "${!v-}")"
  done
}

load_digihub_paths() {
  DigiHubHome="$(profile_get_export 'DigiHub')"
  PythonPath="$(profile_get_export 'DigiHubPy')"
  venv_dir="$(profile_get_export 'DigiHubvenv')"

  if [[ -z "$DigiHubHome" || -z "$PythonPath" || -z "$venv_dir" ]]; then
    printf '%s\n' 'ERROR: DigiHub exports missing in ~/.profile (DigiHub/DigiHubPy/DigiHubvenv). Run installer.' >&2
    exit 1
  fi

  local pline
  pline="$(grep -F 'PATH=' "$PROFILE_FILE" | grep -F "$PythonPath" | tail -n1 || true)"
  if [[ -n "$pline" ]]; then
    PathLine="$pline"
  else
    PathLine="PATH=${DigiHubHome}/Files/scripts:${PythonPath}:\$PATH"
  fi
}

ValidateCoords() {
  if [[ -x "$(command -v python3)" && -f "${PythonPath}/validcoords.py" ]]; then
    python3 "${PythonPath}/validcoords.py" "$lat" "$lon" >/dev/null
  else
    return 0
  fi
}

DeriveGrid() {
  if [[ -x "$(command -v python3)" && -f "${PythonPath}/hamgrid.py" ]]; then
    grid="$(python3 "${PythonPath}/hamgrid.py" "$lat" "$lon")"
  else
    grid="${grid:-Unknown}"
  fi
}

GetGPSLatLon() {
  # gpsposition.py output: Latitude,Longitude
  if [[ ! -x "$(command -v python3)" || ! -f "${PythonPath}/gpsposition.py" ]]; then
    return 1
  fi

  local out
  out="$(python3 "${PythonPath}/gpsposition.py" 2>/dev/null || true)"
  out="$(trim "${out}")"

  # Use first line only
  out="$(printf '%s' "$out" | head -n1)"

  local a b
  a="$(printf '%s' "$out" | awk -F',' '{print $1}' | sed -e 's/^[[:space:]]\+//' -e 's/[[:space:]]\+$//')"
  b="$(printf '%s' "$out" | awk -F',' '{print $2}' | sed -e 's/^[[:space:]]\+//' -e 's/[[:space:]]\+$//')"

  # Basic sanity: both must look like numbers
  if printf '%s' "$a" | grep -Eq '^-?[0-9]+(\.[0-9]+)?$' && printf '%s' "$b" | grep -Eq '^-?[0-9]+(\.[0-9]+)?$'; then
    lat="$a"
    lon="$b"
    return 0
  fi

  return 1
}

UpdateCoordsAndGrid() {
  local tries=0
  local max_tries=5
  while true; do
    if ValidateCoords; then
      DeriveGrid
      return 0
    fi
    ((tries++))
    printf '%s\n' 'Invalid latitude/longitude. Please correct them.' >&2
    PromptEdit lat 'Latitude' 1
    PromptEdit lon 'Longitude' 1
    (( tries >= max_tries )) && { printf '%s\n' 'Too many invalid attempts.' >&2; exit 1; }
  done
}

RecalcAPRS() {
  if [[ -x "$(command -v python3)" && -f "${PythonPath}/aprspass.py" ]]; then
    local out
    out="$(python3 "${PythonPath}/aprspass.py" "$callsign" 2>/dev/null || true)"
    aprspass="$(printf '%s' "$out" | awk '{print $NF}' | tail -n1)"
    aprspass="$(trim "${aprspass}")"
    if [[ -z "$aprspass" ]]; then
      aprspass='Unknown'
      return 1
    fi
    return 0
  fi
  aprspass='Unknown'
  return 1
}


http_get() {
  # http_get URL  -> prints body to stdout, returns 0 on success
  local url="$1"
  if command -v curl >/dev/null 2>&1; then
    curl -fsSL "$url"
    return $?
  fi
  if command -v wget >/dev/null 2>&1; then
    wget -qO- "$url"
    return $?
  fi
  return 1
}

is_non_us_callsign() {
  # returns 0 if callsign is "non-us" (any case, with surrounding spaces ignored)
  local c
  c="$(trim "${callsign}")"
  c="$(printf '%s' "$c" | tr '[:upper:]' '[:lower:]')"
  [[ "$c" == 'non-us' ]]
}

ValidateUSCallsign() {
  # Uses validcall.py exit codes:
  #   0 valid, 1 invalid, 2 usage error
  if [[ ! -x "$(command -v python3)" || ! -f "${PythonPath}/validcall.py" ]]; then
    # If missing, do not block editing; treat as not-validated.
    return 2
  fi
  python3 "${PythonPath}/validcall.py" "${callsign}"
}

HamDBLookup() {
  # Uses HamDB CSV output (simpler and faster than JSON)
  # On success, populates fields if present:
  #   class expiry licstat forename initial surname suffix street town state zip country
  # Returns:
  #   0 = OK and applied, 1 = not found/invalid, 2 = lookup/parsing error

  local url
  url="https://hamdb.org/${callsign}/csv/dhedit"

  local line
  if ! line="$(http_get "$url" 2>/dev/null | head -n1 || true)"; then
    return 2
  fi

  # Expected CSV order from HamDB:
  # callsign,class,expires,status,fname,mi,name,suffix,addr1,addr2,state,zip,country
  # NOTE: some fields may be empty

  IFS=',' read -r \
    hb_callsign hb_class hb_expiry hb_status \
    hb_fname hb_mi hb_name hb_suffix \
    hb_addr1 hb_addr2 hb_state hb_zip hb_country <<< "$line"

  # If callsign field is empty or mismatch, treat as not found
  if [[ -z "$(trim "${hb_callsign}")" ]]; then
    return 1
  fi

  # Apply only non-empty values (never overwrite with blanks)
  [[ -n "$(trim "${hb_class}")"  ]] && class="$(trim "${hb_class}")"
  [[ -n "$(trim "${hb_expiry}")" ]] && expiry="$(trim "${hb_expiry}")"
  [[ -n "$(trim "${hb_status}")" ]] && licstat="$(trim "${hb_status}")"

  [[ -n "$(trim "${hb_fname}")"  ]] && forename="$(trim "${hb_fname}")"
  [[ -n "$(trim "${hb_mi}")"     ]] && initial="$(trim "${hb_mi}")"
  [[ -n "$(trim "${hb_name}")"   ]] && surname="$(trim "${hb_name}")"
  [[ -n "$(trim "${hb_suffix}")" ]] && suffix="$(trim "${hb_suffix}")"

  [[ -n "$(trim "${hb_addr1}")"  ]] && street="$(trim "${hb_addr1}")"
  [[ -n "$(trim "${hb_addr2}")"  ]] && town="$(trim "${hb_addr2}")"
  [[ -n "$(trim "${hb_state}")"  ]] && state="$(trim "${hb_state}")"
  [[ -n "$(trim "${hb_zip}")"    ]] && zip="$(trim "${hb_zip}")"
  [[ -n "$(trim "${hb_country}")"]] && country="$(trim "${hb_country}")"

  # Normalize optionals (NOT initial/suffix)
  SetUnknownIfEmpty class expiry licstat forename surname street town state zip country
  BuildFullName
  BuildAddress
  return 0
}

HandleCallsignChange() {
  # Behavior:
  # - If callsign is "non-us" (any case): skip validation + HamDB
  # - If US callsign validates: query HamDB and apply any data found
  # - If invalid: do nothing (user can still proceed, but won't auto-fill)
  if is_non_us_callsign; then
    return 0
  fi

  local rc
  ValidateUSCallsign
  rc=$?

  case "$rc" in
    0)
      HamDBLookup || true
      ;;
    1)
      # Invalid callsign format; don't query HamDB
      ;;
    2)
      # Validator missing or usage error; skip HamDB
      ;;
    *)
      ;;
  esac
}

ReviewAndEdit() {
  while true; do
    printf '\n================ REVIEW =================\n'
    printf ' 1) Callsign:   %s\n' "${callsign:-}"
    printf ' 2) GPS Port:   %s\n' "${gpsport:-}"
    printf ' 3) Latitude:   %s\n' "${lat:-}"
    printf ' 4) Longitude:  %s\n' "${lon:-}"
    printf ' 5) Grid:       %s\n' "${grid:-}"
    printf ' 6) APRS Pass:  %s\n' "${aprspass:-}"
    printf ' 7) AX25 Pass:  %s\n' "${axnodepass:-}"
    printf ' 8) Class:      %s\n' "${class:-}"
    printf ' 9) Expiry:     %s\n' "${expiry:-}"
    printf '10) Lic Status: %s\n' "${licstat:-}"
    printf '11) Forename:   %s\n' "${forename:-}"
    printf '12) Initial:    %s\n' "${initial:-}"
    printf '13) Surname:    %s\n' "${surname:-}"
    printf '14) Suffix:     %s\n' "${suffix:-}"
    printf '15) Street:     %s\n' "${street:-}"
    printf '16) Town/City:  %s\n' "${town:-}"
    printf '17) State:      %s\n' "${state:-}"
    printf '18) ZIP/Postal: %s\n' "${zip:-}"
    printf '19) Country:    %s\n' "${country:-}"
    printf '----------------------------------------\n'
    printf ' Full Name:     %s\n' "${fullname:-}"
    printf ' Address:       %s\n' "${address:-}"
    printf '========================================\n'

    local choice
    read -r -p 'Enter a number to edit (1-19), or press Enter to accept: ' choice
    [[ -z "$choice" ]] && return 0

    case "$choice" in
      1) PromptEdit callsign 'Callsign' 1 ;;
      2) PromptEdit gpsport  'DigiHubGPSport (nogps or device port)' 0 ;;
      3) PromptEdit lat      'Latitude' 1 ;;
      4) PromptEdit lon      'Longitude' 1 ;;
      5) printf '%s\n' 'Grid is derived from lat/lon. Edit lat/lon to change it.' ;;
      6) PromptEdit aprspass 'APRS password' 0 ;;
      7) PromptEdit axnodepass 'AX25 password' 0 ;;
      8) PromptEdit class    'License Class' 0 ;;
      9) PromptEdit expiry   'Expiry' 0 ;;
      10) PromptEdit licstat 'License Status' 0 ;;
      11) PromptEdit forename 'Forename' 0 ;;
      12) PromptEdit initial  'Middle Initial (optional)' 0 ;;
      13) PromptEdit surname  'Surname' 0 ;;
      14) PromptEdit suffix   'Suffix (optional)' 0 ;;
      15) PromptEdit street   'Street' 0 ;;
      16) PromptEdit town     'Town/City' 0 ;;
      17) PromptEdit state    'State' 0 ;;
      18) PromptEdit zip      'ZIP/Postal' 0 ;;
      19) PromptEdit country  'Country' 0 ;;
      *) printf '%s\n' 'Invalid selection.' >&2 ;;
    esac

    SetUnknownIfEmpty class expiry licstat forename surname street town state zip country gpsport aprspass axnodepass
    BuildFullName
    BuildAddress

    if [[ "$choice" == '3' || "$choice" == '4' ]]; then
      UpdateCoordsAndGrid
    fi

    if [[ "$choice" == '1' ]]; then
      HandleCallsignChange || true
      # Callsign changed: automatically recalc APRS password (installer behavior)
      RecalcAPRS || true
    fi
  done
}

write_dhinfo() {
  backup_file "$DHINFO_FILE"
  printf '%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s\n' \
    "$callsign" "$class" "$expiry" "$grid" "$lat" "$lon" "$licstat" \
    "$forename" "$initial" "$surname" "$suffix" \
    "$street" "$town" "$state" "$zip" "$country" > "$DHINFO_FILE"
}

write_profile() {
  backup_file "$PROFILE_FILE"
  if [[ "${gpsport}" == 'nodata' ]]; then gpsport='nogps'; fi

  profile_set_export 'DigiHubGPSport' "$gpsport"
  profile_set_export 'DigiHubcall' "$callsign"
  profile_set_export 'DigiHubaprs' "$aprspass"
  profile_set_export 'DigiHubaxnode' "$axnodepass"
  profile_set_export 'DigiHubLat' "$lat"
  profile_set_export 'DigiHubLon' "$lon"
  profile_set_export 'DigiHubgrid' "$grid"

  profile_set_path_line "$PathLine"
}

# --------------- Main ---------------

require_profile
load_digihub_paths

gpsport="$(profile_get_export 'DigiHubGPSport')"
callsign_env="$(profile_get_export 'DigiHubcall')"
aprspass="$(profile_get_export 'DigiHubaprs')"
axnodepass="$(profile_get_export 'DigiHubaxnode')"
lat_env="$(profile_get_export 'DigiHubLat')"
lon_env="$(profile_get_export 'DigiHubLon')"
grid_env="$(profile_get_export 'DigiHubgrid')"

load_from_dhinfo

[[ -n "$(trim "${callsign_env}")" ]] && callsign="$callsign_env"
[[ -n "$(trim "${lat_env}")" ]] && lat="$lat_env"
[[ -n "$(trim "${lon_env}")" ]] && lon="$lon_env"
[[ -n "$(trim "${grid_env}")" ]] && grid="$grid_env"

SetUnknownIfEmpty gpsport callsign aprspass axnodepass
SetUnknownIfEmpty class expiry licstat forename surname street town state zip country
BuildFullName
BuildAddress

printf '\n%s\n' 'DigiHub Configuration Editor (dhedit)'
printf '%s\n' "Profile: ${PROFILE_FILE}"
printf '%s\n' "Data:    ${DHINFO_FILE}"
printf '\n%s\n' 'Continue?'
YnCont || exit 0

old_callsign="${callsign}"
PromptEdit callsign 'Callsign' 1
if [[ "${callsign}" != "${old_callsign}" ]]; then
  HandleCallsignChange || true
  RecalcAPRS || true
fi

printf '\n%s\n' 'Update Latitude/Longitude:'
printf '%s\n' '  1) Use current values (no change)'
printf '%s\n' '  2) Enter manually'
printf '%s\n' '  3) Read from GPS (gpsposition.py)'
read -r -p 'Select 1-3: ' mode

case "${mode:-1}" in
  1) ;;
  2)
    PromptEdit lat 'Latitude' 1
    PromptEdit lon 'Longitude' 1
    ;;
  3)
    printf '\n%s\n' 'Attempting to read GPS position...'
    if GetGPSLatLon; then
      printf '%s\n' "GPS returned lat=${lat} lon=${lon}"
    else
      printf '%s\n' 'GPS read failed. Enter manually instead.' >&2
      PromptEdit lat 'Latitude' 1
      PromptEdit lon 'Longitude' 1
    fi
    ;;
  *)
    printf '%s\n' 'Invalid selection; keeping current coordinates.' >&2
    ;;
esac

UpdateCoordsAndGrid

printf '\n%s\n' 'Do you want to enter or edit your name fields?'
if YnCont; then
  PromptEdit forename 'Forename' 0
  PromptEdit initial  'Middle Initial (optional)' 0
  PromptEdit surname  'Surname' 0
  PromptEdit suffix   'Suffix (optional)' 0
fi

printf '\n%s\n' 'Do you want to enter or edit your address fields?'
if YnCont; then
  PromptEdit street  'Street' 0
  PromptEdit town    'Town/City' 0
  PromptEdit state   'State' 0
  PromptEdit zip     'ZIP/Postal' 0
  PromptEdit country 'Country' 0
fi

printf '\n%s\n' 'Do you want to enter or edit license fields (class/expiry/status)?'
if YnCont; then
  PromptEdit class   'License Class' 0
  PromptEdit expiry  'Expiry' 0
  PromptEdit licstat 'License Status' 0
fi

printf '\n%s\n' 'Do you want to edit GPS port / APRS / AX25 values?'
if YnCont; then
  PromptEdit gpsport    'DigiHubGPSport (nogps or device port)' 0
  printf '\n%s\n' 'Recalculate APRS password from callsign now?'
  if YnCont; then
    RecalcAPRS || true
  else
    PromptEdit aprspass  'DigiHubaprs' 0
  fi
  PromptEdit axnodepass 'DigiHubaxnode' 0
fi

SetUnknownIfEmpty gpsport class expiry licstat forename surname street town state zip country aprspass axnodepass
BuildFullName
BuildAddress

ReviewAndEdit

SetUnknownIfEmpty gpsport class expiry licstat forename surname street town state zip country aprspass axnodepass
BuildFullName
BuildAddress
UpdateCoordsAndGrid

write_profile
write_dhinfo

printf '\n%s\n' 'Updated configuration:'
printf '%s\n' "  - ${PROFILE_FILE}"
printf '%s\n' "  - ${DHINFO_FILE}"
printf '\n%s\n' 'Open a new shell or run: source ~/.profile'